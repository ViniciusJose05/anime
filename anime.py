# -*- coding: utf-8 -*-
"""anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OwJb1_8QjbIvOSElGqKC8x-H_iecRHnA

# An√°lise de Dados em S√©ries de Anime:  G√™neros, Avalia√ß√µes e Tend√™ncias

### Equipe:
* Maria J√∫lia Silva Fonseca Guedes Nobre
* Vin√≠cius Jos√© Arag√£o de Almeida Barrozo

### Objetivos:
- Identificar os g√™neros mais frequentes.
- Avaliar quais g√™neros t√™m as melhores (e piores) notas m√©dias.
- Descobrir as combina√ß√µes de g√™neros mais comuns.
- Analisar a rela√ß√£o entre popularidade e avalia√ß√£o.
- Testar um modelo preditivo baseado nas avalia√ß√µes.

# 1. Inicializa√ß√£o da Database

Download dos arquivos via API do kaggle e cria√ß√£o do dataframe inicial
"""

import kagglehub
import polars as pl

# Baixar e carregar o dataset
path = kagglehub.dataset_download("hernan4444/anime-recommendation-database-2020")
anime_polars = pl.read_csv(path + "/anime.csv", null_values="Unknown")

anime_polars.head()

"""# 2. Pr√© Processamento

###  2.1. Remover valores nulos em colunas importantes (`Genres` e `Scores`)
"""

df_clean = anime_polars.filter(
    (anime_polars['Genres'].is_not_null()) & (anime_polars['Score'].is_not_null())
)

print(df_clean)

"""### 2.2. Separar a coluna `Genres` em uma lista"""

df_clean = df_clean.with_columns(
    pl.col('Genres')
    .str.replace("Hentai", "Adult Content")
    .str.split(", ")                       # converte para lista
)

print(df_clean)

"""###  2.3. Criar coluna com combina√ß√£o ordenada dos g√™neros"""

def process_genres(genres):
    try:
        if genres is not None and len(genres) > 0:
            return ", ".join(sorted(genres))
        else:
            return ""
    except (TypeError, AttributeError):
        return ""

df_clean = df_clean.with_columns(
    pl.col('Genres').map_elements(process_genres, return_dtype=pl.Utf8).alias('Genres_combination')
)
# download em formato json da database polars
df_clean.write_json('df_clean.json')

"""# 3. An√°lises Explorat√≥rias"""

import plotly.express as px

# Explodir para an√°lise individual de g√™neros
df_exploded = df_clean.explode('Genres')

print(df_clean)

"""### 3.1. G√™neros mais frequentes

"""

genero_freq = (
    df_exploded.group_by('Genres')
    .len()
    .sort('len', descending=True)
    .rename({'len': 'Frequencia'})
)

px.bar(genero_freq.to_pandas(), x='Genres', y='Frequencia', title='G√™neros Mais Frequentes').show()

"""### 3.2. Nota m√©dia por g√™nero"""

genero_score = (
    df_exploded.group_by('Genres')
    .agg(pl.col('Score').mean().alias('Nota M√©dia'))
    .sort('Nota M√©dia', descending=True)
)

px.bar(genero_score.head(15).to_pandas(), x='Genres', y='Nota M√©dia', title='Top 15 G√™neros com Melhores Notas').show()
px.bar(genero_score.tail(15).to_pandas(), x='Genres', y='Nota M√©dia', title='15 G√™neros com Piores Notas').show()

"""### 3.3. Combina√ß√µes de g√™neros mais comuns"""

df_combos = df_clean.filter(pl.col('Genres').list.len() > 1)

combo_freq = (
    df_combos
    .group_by('Genres_combination')
    .agg(pl.count().alias('Frequencia'))
    .sort('Frequencia', descending=True)
)

px.bar(combo_freq.head(15).to_pandas(), x='Genres_combination', y='Frequencia',
       title='üîó Combina√ß√µes de G√™neros Mais Comuns (com 2 ou mais g√™neros)').show()

"""### 3.4. Est√∫dios com melhor nota m√©dia

"""

df_studios = df_clean.filter(
    (pl.col('Studios').is_not_null()) & (pl.col('Studios') != "None")
)

# Agrupar por est√∫dio e calcular m√©dia e contagem
studio_avg = (
    df_studios
    .group_by('Studios')
    .agg([
        pl.col('Score').mean().alias('Nota M√©dia'),
        pl.count().alias('Quantidade de Animes')
    ])
    .filter(pl.col('Quantidade de Animes') >= 5)
    .sort('Nota M√©dia', descending=True)
)

fig = px.bar(
    studio_avg.head(15).to_pandas(),  # Top 15 est√∫dios com melhor nota m√©dia
    x='Studios',
    y='Nota M√©dia',
    title='üé¨ Est√∫dios com as Melhores Notas M√©dias (com pelo menos 5 animes)',
    text='Nota M√©dia',
    labels={'Studios': 'Est√∫dio', 'Nota M√©dia': 'Nota M√©dia'}
)
fig.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig.update_layout(xaxis_tickangle=-45)
fig.show()

""" ### 3.5. Rela√ß√£o entre popularidade e avalia√ß√£o"""

relacao_popularidade = df_clean.select(['Score', 'Members', 'Genres_combination']).to_pandas()

px.scatter(relacao_popularidade, x='Score', y='Members', color='Genres_combination',
           size='Members', hover_data=['Genres_combination'],
           title='Rela√ß√£o entre Nota e Popularidade por G√™nero').show()

"""# 4. Modelo SVM para predi√ß√£o de notas

### 4.1. Filtragem das colunas necess√°rias
"""

df_clean.columns

df_para_ml = df_clean.select(
    ['MAL_ID','Name', 'Genres', 'Score']
)

df_para_ml_com_membros = df_clean.select(
    ['MAL_ID','Name', 'Genres', 'Score', 'Members']
)

"""### 4.2. One-Hot Encoding nos generos das listas de cada linha

Uso de Machine Learning utilizando a database a fim de validar as transforma√ß√µes realizadas e uso da mesma
"""

def one_hot_encode(df, column_name):
    # Get all unique genres
    all_genres = df[column_name].explode().unique().sort()

    expressions = []
    for genre in all_genres:
        expressions.append(
            pl.col(column_name).list.contains(genre).alias(f"{column_name}_{genre}")
        )

    df = df.with_columns(expressions)
    return df.drop(column_name)

df_para_ml = one_hot_encode(df_para_ml, 'Genres')
df_para_ml = df_para_ml.drop('Name', 'MAL_ID')

df_para_ml_com_membros = one_hot_encode(df_para_ml_com_membros, 'Genres')
df_para_ml_com_membros = df_para_ml_com_membros.drop('Name', 'MAL_ID')

df_para_ml.head(), df_para_ml_com_membros.head()

# download dos dataframes polars em csv
df_para_ml.write_csv('df_para_ml.csv')
df_para_ml_com_membros.write_csv('df_para_ml_com_membros.csv')

"""### 4.3. Fun√ß√£o de treinamento e teste

Implementa√ß√£o de modelo de SVM utilizando 10-10-fold para predi√ß√£o da nota baseado em generos, contendo ou n√£o o numero de membros de cada entrada.
"""

from sklearn.model_selection import KFold
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error
import numpy as np

def train_and_evaluate_knn(df, n_neighbors=5):
    # Separate features (X) and target (y)
    # Assuming 'Score' is the target variable and the rest are features
    X = df.drop('Score').to_numpy()
    y = df['Score'].to_numpy()

    # Define the number of folds
    n_folds = 10

    # Initialize KFold
    kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)

    # Initialize list to store evaluation scores
    mse_scores = []

    # Loop through each fold
    for train_index, test_index in kf.split(X):
        X_train, X_test = X[train_index], X[test_index]
        y_train, y_test = y[train_index], y[test_index]

        # Initialize the KNeighborsRegressor model
        model = KNeighborsRegressor(n_neighbors=n_neighbors)

        # Train the model
        model.fit(X_train, y_train)

        # Predict on the test set
        y_pred = model.predict(X_test)

        # Evaluate the model using Mean Squared Error
        mse = mean_squared_error(y_test, y_pred)
        mse_scores.append(mse)

    # Calculate the average MSE across all folds
    average_mse = np.mean(mse_scores)

    return average_mse, mse_scores

"""### 4.4. Resultados do modelo

4.4.1. Modelo somente com Score e generos
"""

average_mse, mse_scores = train_and_evaluate_knn(df_para_ml)
print("MSE por fold:", mse_scores)
print("M√©dia do erro quadr√°tico m√©dio:", average_mse)

"""4.4.2. Modelo com n√∫mero de membros"""

average_mse_membros, mse_scores_membros = train_and_evaluate_knn(df_para_ml_com_membros)
print(f"MSE por fold: {mse_scores_membros}")
print(f"M√©dia do erro quadr√°tico m√©dio: {average_mse_membros}")